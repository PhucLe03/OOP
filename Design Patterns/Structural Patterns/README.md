# &nbsp;&nbsp;&nbsp;&nbsp;Structural Patterns

&nbsp;&nbsp;&nbsp;&nbsp;Structural Patterns là nhóm các Patterns phục vụ việc lắp ráp các class thành các cấu trúc lớn hơn mà vẫn đảm bảo tính linh hoạt và hiệu quả. Nhóm gồm này gồm 7 mẫu: Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy.

&nbsp;&nbsp;&nbsp;&nbsp;Các class Structural Patterns sử dụng tính kế thừa để tổng hợp interfaces hoặc implementations (code triển khai, code hiện thực). Structural Patterns đặc biệt hữu dụng khi muốn các class trong thư viện có thể phát triển một cách độc lập với nhau, hoặc khi muốn cung cấp một abstraction thống nhất cho các interface khác nhau. Ví dụ như cách mà tính kế thừa gom hai hoặc nhiều class lại làm một, kết quả là một class sở hữu những thuộc tính của những class cha của nó; cách này được sử dụng khi cần cho nhiều class riêng biệt hoạt động chung với nhau. Một ví dụ khác là cách triển khai của Adapter Pattern. Adapter Pattern làm cho một interface (của Adaptee) phù hợp với interface khác, nhờ đó cung cấp cho các interface khác nhau một sự thống nhất một cách trừu tượng.

&nbsp;&nbsp;&nbsp;&nbsp;Ngoài tổng hợp interface và implementation, các đối tượng Structural Pattern mô tả những cách tạo đối tượng để hiện thực những chức năng mới. Tính linh hoạt được bổ sung vào các thành phần đối tượng xuất phát từ khả năng thay đổi thành phần trong run-time, điều mà các thành phần static class không thể làm.

&nbsp;&nbsp;&nbsp;&nbsp;Composite Pattern là một ví dụ Structural Patterns mô tả cách dựng một cấu trúc phân cấp class tạo bởi các class dùng cho hai dạng đối tượng: nguyên thủy (primitive) và hỗn hợp (composite). Các đối tượng hỗn hợp cho phép kết hợp các đối tượng nguyên thủy và các đối tượng hỗn hợp khác thành các cấu trúc phức tạp tùy ý. Đối với Proxy Pattern, một Proxy hành động như một vật thay thế (surrogate) hoặc vật giữ chỗ (placeholder) cho một đối tượng khác. Proxy có thể được dùng bằng nhiều cách khác nhau; Proxy có thể đóng vai trò là một đại diện cục bộ (local local representative) cho một đối tượng ở xa xôi, có thể đại diện cho một đối tượng lớn mà cần nhiều thời gian để tải, có thể bảo vệ truy cập vào những đối tượng nhạy cảm. Các Proxy có thể hạn chế, tăng cường hoặc thay đổi các thuộc tính cụ thể của các đối tượng.

&nbsp;&nbsp;&nbsp;&nbsp;Flyweight Pattern định nghĩa một cấu trúc để chia sẻ các đối tượng. Các đối tượng được chia sẻ do một số lý do như: hiệu quả (efficiency) và nhất quán (consistency). Flyweight tập trung vào việc chia sẻ để đạt hiệu quả về không gian. Các ứng dụng sử dụng nhiều đối tượng phải chú ý cẩn thận đến chi phí của từng đối tượng. Chia sẻ đối tượng tiết kiệm được đáng kể so với sao chép chúng.

&nbsp;&nbsp;&nbsp;&nbsp;Facade Pattern giúp tạo một đối tượng duy nhất đại diện cho toàn bộ hệ thống con (subsystem). Một Facade là một đại diện cho một tập hợp các đối tượng. Facade thực hiện trách nhiệm của mình bằng cách chuyển tiếp các thông điệp đến các đối tượng mà nó đại diện. Bridge Pattern tách phần trừu tượng (abstraction) của đối tượng khỏi phần triển khai (implementation) của nó để bạn có thể thay đổi chúng một cách độc lập.

&nbsp;&nbsp;&nbsp;&nbsp;Decorator Pattern diễn tả cách bổ sung động (dynamically) các chức năng cho đối tượng. Decorator Pattern tổng hợp các đối tượng bằng đệ quy, cho phép sự bổ sung chức năng, trách nhiệm không giới hạn. Các đối tượng Decorator được bổ sung chức năng bằng cách lồng các Decorator lại với nhau. Để làm được điều đó, mỗi đối tượng Decorator trong hệ thống phải có interface phù hợp với nhau và phải truyền được thông điệp cho nhau.

&nbsp;&nbsp;&nbsp;&nbsp;Phần mềm bị thay đổi tính năng là điều xảy ra như “cơm bữa”. Nếu không muốn mỗi lần thay đổi là một lần phải “đập đi xây lại cả hệ thống”, thì chúng ta nên có cách tổ chức linh hoạt để có thể thực hiện sự thay đổi dễ dàng hơn.
